testCommonCode;


GInvParam.isParallel = 1;
GInvParam.isPrintBySavingFile = 0;


[inIds, crossIds] = bsGetProfileCrossingWells(GInvParam, wellLogs([23, 21, 18, 53, 80, 75]), ...
    'isAlongCrossline', 0);

% [inIds, crossIds] = bsGetProfileCrossingWells(GInvParam, wellLogs([80]), ...
%     'isAlongCrossline', 1);

% inverse a profile
% [~, ~, GInvParam, data] = bsBuildInitModel(GInvParam, timeLine, wellLogs, ...
%     'title', 'cross_well', ...
%     'inIds', inIds, ...
%     'filtCoef', 0.15, ...
%     'crossIds', crossIds, ...
%     'isRebuild', 1, ...
%     'p', 2, ...
%     'nPointsUsed', 20 ...
% );


methods = {
    
    struct(...
        'name', 'Seismic (phase shifte 90)', ...
        'type', 'Seismic', ...
        'load', struct(...
            'mode', 'segy', ...
            'fileName', [basePath, '/seismic/phase_shift_90.sgy'], ...
            'segyInfo', bsSetFields(GSegyInfo, {'inlineId', 9; 'crossId', 21; 't0', 0; 'isNegative', 0}) ...
        )...
    );...
    
    
    struct(...
        'name', 'Initial model', ...
        'isSaveMat', 0, ...
        'load', struct(...
            'mode', 'segy', ...
            'fileName', GInvParam.initModel.ip.fileName, ...
            'segyInfo', GInvParam.initModel.ip.segyInfo ...
        )...
    );...

    
% 
%     struct(...
%         'name', 'HAGCS', ...
%         'flag', 'HAGCS', ...
%         'regParam', 0.02, ...
%         'parampkgs', [], ...
%         'isSaveMat', 1, ...
%         'options', bsSetFields(GInvParam.seisInvOptions, {'regFunc', @bsReg1DTV; ...
%             'addLowFreqConstraint', 1; ...
%             'initRegParam', 0.05}) ...
%     );
    
%     struct(...
%         'name', 'TV', ...
%         'flag', 'TV', ...
%         'regParam', -0.02, ...
%         'parampkgs', struct('diffOrder', 1), ...
%         'options', bsSetFields(GInvParam.seisInvOptions, {'maxIter', 200; 'initRegParam', 0.05}), ...
%         'showFiltCoef', 1, ...
%         'isSaveMat', 1, ...
%         'load', struct(...
%             'mode', 'off', ...
%             'fileName', '' ...
%         )...
%     ); 
%     
    struct(...
        'name', 'Low Frequency Constraint', ...
        'flag', 'LFC', ...
        'regParam', 0.1, ...
        'parampkgs', [], ...
        'options', bsSetFields(GInvParam.seisInvOptions, {'maxIter', 50;}), ...
        'showFiltCoef', 0, ...
        'isSaveMat', 0 ...
    ); 


    struct(...
        'name', 'DLSR (gamma=0.2 sparsity=2)', ...
        'flag', 'DLSR', ...
        'regParam', struct('lambda', 1, 'gamma', 0.2), ...
        'parampkgs', bsSetFields(GSparseInvParam, {'sparsity', 2}), ...
        'options', bsSetFields(GInvParam.seisInvOptions, ...
            {'maxIter', 5; 'innerIter', 40; 'initRegParam', 0.1}), ...
        'isSaveSegy', 0, ...
        'isSaveMat', 0, ...
        'load', struct(...
            'mode', 'off', ...
            'fileName', '' ...
        )...
    );
    
    
    struct(...
        'name', 'Chen Ting', ...
        'isSaveMat', 0, ...
        'load', struct(...
            'mode', 'segy', ...
            'fileName', [basePath, '\inv_result\SMIResult1_2.sgy'], ...
            'segyInfo', bsSetFields(GSegyInfo, {'inlineId', 9; 'crossId', 21; 't0', 0}) ...
        )...
    );...
    
    
%     
%     
    struct(...
        'name', 'Sparse Impulse', ...
        'isSaveMat', 0, ...
        'load', struct(...
            'mode', 'segy', ...
            'fileName', [basePath, '\inv_result\geoeast_impedance_sparse_impulse_bgp.sgy'], ...
            'segyInfo', bsSetFields(GSegyInfo, {'inlineId', 189; 'crossId', 21; 't0', 780}) ...
        )...
    );...
% % %     
%     
% % %     
};

% perform the inversion process based on given methods
invResults = bsPostInvTrueMultiTraces(GInvParam, inIds, crossIds, timeLine, methods);

% invResults = [{bsSetFields(invResults{1}, {'name', 'Minus error model'; 'data', usedData})}, invResults];

% smooth the inversion results
NLMResults = invResults;
NLMResults(4) = bsNLMInvResults(invResults(4), [], ...
    'searchOffset', 4, 'windowSize', [1, 4], 'nPointsUsed', 4, ...
    'stride', [1, 1, 1], 'searchStride', [1, 1, 1] ...
);

GShowProfileParam.range.ip = [6000 7800];
GShowProfileParam.range.seismic = [-3 3]*1e4;
GShowProfileParam.colormap.allTheSame = bsGetColormap('velocity');
GShowProfileParam.isColorReverse = 1;

GShowProfileParam.scaleFactor = 3;
GShowProfileParam.showWellOffset = 1;
GShowProfileParam.plotParam.fontsize = 11;
% GShowProfileParam.showPartVert.upTime = 5;
% GShowProfileParam.showPartVert.downTime = 120;
% GShowProfileParam.showPartVert.mode = 'up_down_time';
GShowProfileParam.showPartVert.mode = 'in_2_horizons';
GShowProfileParam.showPartVert.horizonIds = [1, 3];
% GShowProfileParam.showPartVert.mode = 'off';

GShowProfileParam.isShowHorizon = 0;
bsShowInvProfiles(GInvParam, GShowProfileParam, invResults, wellLogs, timeLine);
set(gcf, 'position', [ 96          54        1672         670]);
